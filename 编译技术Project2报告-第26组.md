# 编译技术Project2报告 - 第26组

### 组内分工

朱立人：

宋苑铭：基于语法树变换的简单自动求导

魏龙：求导语句中变量代换

### 自动求导技术设计

我们首先直接根据张量表达式变换设计了自动求导方案，然后改写得到基于语法树变换的简单自动求导编译器，并加入了对求导语句进行变量代换的功能。

### 实现流程

1. 使用jsoncpp解析输入json文件，得到测试数据的相关信息，并进行必要的预处理。复用project1中的代码，对表达式进行词法分析和语法分析，并构建IR树。
2. 对于每个“形式不同”的待求导变量，使用DiffMutator对语法树进行变换得到求导代码。比如，对`A[i] = B[i]+B[i+1]`，`B[i], B[i+1]`下标不完全相同，因而形式不同。根据求导的性质，将出现在表达式不同位置的变量看作不同变量求导，结果仍然正确。DiffMutator根据反向传播原理，将循环体内形如`A[i] = A[i] + f(B[g(i)])`的语句变为`dB[g(i)] = dB[g(i)] + dA[i] * df(B[g(i)])`，不改变循环结构。使用SimplifyMutator对求导代码进行化简，以得到相对简洁的代码，并保证代码中出现的变量都会被实际用到。
3. 由于语句左侧下标索引上不能有运算，故需要进行变量代换。考虑到通用实现方法相对复杂，而测试用例形式较简单，故只考虑对下标上出现的单次加法、除法、取模进行相应代换。如对于 `A[i + j] = B[i] * C[j]`，令 `i + j = i0`，则原语句替换成 `A[i0] = B[i] * C[i0 - i]`；对于 `A[i / 16][i % 16] = B[i]`，令 `i / 16 = i0`, `i % 16 = i1`，则语句替换为 `A[i0][i1] = B[i0 * 16 + i1]`。整个过程基于 IRMutator 实现。
4. 在求导语句前添加初始化语句，生成函数签名，并复用project1中设计的IRPrinter，打印出kernel的C++代码。

### 实验结果

程序可以正确编译运行，并通过全部10个测试数据。分析出来的求导表达式是一个或多个赋值语句形式，每个语句左侧的下标索引上没有加减乘除等运算。

### 自动求导技术示例

我们讨论case 10的一个简化版，以解释设计的求导技术的可行性和正确性。

测试数据的变量类型为float，张量表达式为`A<8, 8>[i, j] = (B<9, 8>[i, j] + B<9, 8>[i + 1, j]) / 2.0;`，希望求出$dB$。根据求导的数学方法，我们有
$$
dB[i,j]=\frac{\partial loss}{\partial B[i,j]}=\sum_k\frac{\partial loss}{\partial A[k,j]}\frac{\partial A[k,j]}{\partial B[i,j]} = \begin{cases}
(dA[i-1,j]+dA[i,j])/2, &0 < i < 9 \\
dA[i,j]/2, &i = 0 \\
dA[i-1,j]/2, &i = 9
\end{cases}.
$$
下面是我们设计的自动求导技术求解$dB$的过程。首先，对表达式进行词法分析和语法分析，并构建IR树。得到的IR树对应的代码为

```c++
for (int i = 0; i < 8; i++) {
  if (i >= 0 && i < 8 && i < 9 && i + 1 >= 0 && i + 1 < 9) {
    for (int j = 0; j < 8; j++) {
      if (j >= 0 && j < 8) {
        A[i][j] = A[i][j] + ((float) (B[i][j] + B[i + 1][j])) / ((float) 2);
      }
    }
  }
}
```

使用DiffMutator分别对`B[i][j], B[i+1, j]`进行求导，生成两个与上面代码循环结构完全一致的LoopNest，但循环体分别变为

```
dB[i][j] = dB[i][j] + dA[i][j] * (0 + ((float) 1 + 0) / ((float) 2));
```

```c++
dB[i + 1][j] = dB[i + 1][j] + dA[i][j] * (0 + ((float) 0 + 1) / ((float) 2));
```

经过化简后，得到求导代码

```c++
for (int i = 0; i < 8; i++) {
  if (i >= 0 && i < 8 && i < 9 && i + 1 >= 0 && i + 1 < 9) {
    for (int j = 0; j < 8; j++) {
      if (j >= 0 && j < 8) {
        dB[i][j] = dB[i][j] + dA[i][j] * ((float) 1) / ((float) 2);
      }
    }
  }
}
for (int i = 0; i < 8; i++) {
  if (i >= 0 && i < 8 && i < 9 && i + 1 >= 0 && i + 1 < 9) {
    for (int j = 0; j < 8; j++) {
      if (j >= 0 && j < 8) {
        dB[i + 1][j] = dB[i + 1][j] + dA[i][j] * ((float) 1) / ((float) 2);
      }
    }
  }
}
```

目前，赋值语句的左侧下标还有加法运算。对第二个LoopNest进行变量代换，令`i0 = i + 1`，得到

```c++
for (int i0 = 0; i0 < 9; i0++) {
  if (i0 - 1 >= 0 && i0 - 1 < 8 && i0 - 1 < 9 && i0 >= 0 && i0 < 9) {
    for (int j = 0; j < 8; j++) {
      if (j >= 0 && j < 8) {
        dB[i0][j] = dB[i0][j] + dA[i0 - 1][j] * ((float) 1) / ((float) 2);
      }
    }
  }
}
```

添加初始化语句和函数签名后，最终生成的完整求导代码为

```c++
#include "../run2.h"

void grad_case10(float (&dA)[8][8], float (&dB)[9][8]) {
  for (int i0 = 0; i0 < 9; i0++) {
    for (int i1 = 0; i1 < 8; i1++) {
      dB[i0][i1] = 0;
    }
  }
  for (int i = 0; i < 8; i++) {
    if (i >= 0 && i < 8 && i < 9 && i + 1 >= 0 && i + 1 < 9) {
      for (int j = 0; j < 8; j++) {
        if (j >= 0 && j < 8) {
          dB[i][j] = dB[i][j] + dA[i][j] * ((float) 1) / ((float) 2);
        }
      }
    }
  }
  for (int i0 = 0; i0 < 9; i0++) {
    if (i0 - 1 >= 0 && i0 - 1 < 8 && i0 - 1 < 9 && i0 >= 0 && i0 < 9) {
      for (int j = 0; j < 8; j++) {
        if (j >= 0 && j < 8) {
          dB[i0][j] = dB[i0][j] + dA[i0 - 1][j] * ((float) 1) / ((float) 2);
        }
      }
    }
  }
}
```
与使用数学方法得到的求导表达式进行对比，可知生成的求导代码是正确的。

### 使用到的编译知识

- 词法分析，语法分析，语法树构建，语法树遍历，目标代码生成。这些编译知识在project1中已经使用过，详见project1的报告。
- 语法树变换。